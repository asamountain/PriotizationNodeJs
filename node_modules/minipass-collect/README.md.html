<html><head><title>README.md</title></head><body><h1>minipass-collect</h1>
<p>A Minipass stream that collects all the data into a single chunk</p>
<p>Note that this buffers ALL data written to it, so it's only good for
situations where you are sure the entire stream fits in memory.</p>
<p>Note: this is primarily useful for the <code>Collect.PassThrough</code> class, since
Minipass streams already have a <code>.collect()</code> method which returns a promise
that resolves to the array of chunks, and a <code>.concat()</code> method that returns
the data concatenated into a single Buffer or String.</p>
<h2>USAGE</h2>
<pre><code class="language-js">const Collect = require('minipass-collect')

const collector = new Collect()
collector.on('data', allTheData =&gt; {
  console.log('all the data!', allTheData)
})

someSourceOfData.pipe(collector)

// note that you can also simply do:
someSourceOfData.pipe(new Minipass()).concat().then(data =&gt; ...)
// or even, if someSourceOfData is a Minipass:
someSourceOfData.concat().then(data =&gt; ...)
// but you might prefer to have it stream-shaped rather than
// Promise-shaped in some scenarios.
</code></pre>
<p>If you want to collect the data, but <em>also</em> act as a passthrough stream,
then use <code>Collect.PassThrough</code> instead (for example to memoize streaming
responses), and listen on the <code>collect</code> event.</p>
<pre><code class="language-js">const Collect = require('minipass-collect')

const collector = new Collect.PassThrough()
collector.on('collect', allTheData =&gt; {
  console.log('all the data!', allTheData)
})

someSourceOfData.pipe(collector).pipe(someOtherStream)
</code></pre>
<p>All <a href="http://npm.im/minipass">minipass options</a> are supported.</p>
</body></html>