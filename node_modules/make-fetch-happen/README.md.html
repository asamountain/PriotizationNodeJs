<html><head><title>README.md</title></head><body><h1>make-fetch-happen</h1>
<p><a href="https://npm.im/make-fetch-happen"><img src="https://img.shields.io/npm/v/make-fetch-happen.svg" alt="npm version" /></a> <a href="https://npm.im/make-fetch-happen"><img src="https://img.shields.io/npm/l/make-fetch-happen.svg" alt="license" /></a> <a href="https://travis-ci.org/npm/make-fetch-happen"><img src="https://img.shields.io/travis/npm/make-fetch-happen.svg" alt="Travis" /></a> <a href="https://coveralls.io/github/npm/make-fetch-happen?branch=latest"><img src="https://coveralls.io/repos/github/npm/make-fetch-happen/badge.svg?branch=latest" alt="Coverage Status" /></a></p>
<p><a href="https://github.com/npm/make-fetch-happen"><code>make-fetch-happen</code></a> is a Node.js
library that wraps <a href="https://github.com/npm/minipass-fetch"><code>minipass-fetch</code></a> with additional
features <a href="https://github.com/npm/minipass-fetch"><code>minipass-fetch</code></a> doesn't intend to include, including HTTP Cache support, request
pooling, proxies, retries, <a href="#features">and more</a>!</p>
<h2>Install</h2>
<p><code>$ npm install --save make-fetch-happen</code></p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#example">Example</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#api">API</a>
<ul>
<li><a href="#fetch"><code>fetch</code></a></li>
<li><a href="#fetch-defaults"><code>fetch.defaults</code></a></li>
<li><a href="#minipass-fetch-options"><code>minipass-fetch</code> options</a></li>
<li><a href="#extra-options"><code>make-fetch-happen</code> options</a>
<ul>
<li><a href="#opts-cache-path"><code>opts.cachePath</code></a></li>
<li><a href="#opts-cache"><code>opts.cache</code></a></li>
<li><a href="#opts-proxy"><code>opts.proxy</code></a></li>
<li><a href="#opts-no-proxy"><code>opts.noProxy</code></a></li>
<li><a href="#https-opts"><code>opts.ca, opts.cert, opts.key</code></a></li>
<li><a href="#opts-max-sockets"><code>opts.maxSockets</code></a></li>
<li><a href="#opts-retry"><code>opts.retry</code></a></li>
<li><a href="#opts-onretry"><code>opts.onRetry</code></a></li>
<li><a href="#opts-integrity"><code>opts.integrity</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#wow">Message From Our Sponsors</a></li>
</ul>
<h3>Example</h3>
<pre><code class="language-javascript">const fetch = require('make-fetch-happen').defaults({
  cachePath: './my-cache' // path where cache will be written (and read)
})

fetch('https://registry.npmjs.org/make-fetch-happen').then(res =&gt; {
  return res.json() // download the body as JSON
}).then(body =&gt; {
  console.log(`got ${body.name} from web`)
  return fetch('https://registry.npmjs.org/make-fetch-happen', {
    cache: 'no-cache' // forces a conditional request
  })
}).then(res =&gt; {
  console.log(res.status) // 304! cache validated!
  return res.json().then(body =&gt; {
    console.log(`got ${body.name} from cache`)
  })
})
</code></pre>
<h3>Features</h3>
<ul>
<li>Builds around <a href="https://npm.im/minipass-fetch"><code>minipass-fetch</code></a> for the core <a href="https://fetch.spec.whatwg.org"><code>fetch</code> API</a> implementation</li>
<li>Request pooling out of the box</li>
<li>Quite fast, really</li>
<li>Automatic HTTP-semantics-aware request retries</li>
<li>Cache-fallback automatic &quot;offline mode&quot;</li>
<li>Proxy support (http, https, socks, socks4, socks5)</li>
<li>Built-in request caching following full HTTP caching rules (<code>Cache-Control</code>, <code>ETag</code>, <code>304</code>s, cache fallback on error, etc).</li>
<li>Customize cache storage with any <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">Cache API</a>-compliant <code>Cache</code> instance. Cache to Redis!</li>
<li>Node.js Stream support</li>
<li>Transparent gzip and deflate support</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">Subresource Integrity</a> support</li>
<li>Literally punches nazis</li>
<li>(PENDING) Range request caching and resuming</li>
</ul>
<h3>Contributing</h3>
<p>The make-fetch-happen team enthusiastically welcomes contributions and project participation! There's a bunch of things you can do if you want to contribute! The <a href="https://github.com/npm/cli/blob/latest/CONTRIBUTING.md">Contributor Guide</a> outlines the process for community interaction and contribution. Please don't hesitate to jump in if you'd like to, or even ask us questions if something isn't clear.</p>
<p>All participants and maintainers in this project are expected to follow the <a href="https://www.npmjs.com/policies/conduct">npm Code of Conduct</a>, and just generally be excellent to each other.</p>
<p>Please refer to the <a href="CHANGELOG.md">Changelog</a> for project history details, too.</p>
<p>Happy hacking!</p>
<h3>API</h3>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; fetch(uriOrRequest, [opts]) -&gt; Promise&lt;Response&gt;</code></h4>
<p>This function implements most of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch</code> API</a>: given a <code>uri</code> string or a <code>Request</code> instance, it will fire off an http request and return a Promise containing the relevant response.</p>
<p>If <code>opts</code> is provided, the <a href="#minipass-fetch-options"><code>minipass-fetch</code>-specific options</a> will be passed to that library. There are also <a href="#extra-options">additional options</a> specific to make-fetch-happen that add various features, such as HTTP caching, integrity verification, proxy support, and more.</p>
<h5>Example</h5>
<pre><code class="language-javascript">fetch('https://google.com').then(res =&gt; res.buffer())
</code></pre>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; fetch.defaults([defaultUrl], [defaultOpts])</code></h4>
<p>Returns a new <code>fetch</code> function that will call <code>make-fetch-happen</code> using <code>defaultUrl</code> and <code>defaultOpts</code> as default values to any calls.</p>
<p>A defaulted <code>fetch</code> will also have a <code>.defaults()</code> method, so they can be chained.</p>
<h5>Example</h5>
<pre><code class="language-javascript">const fetch = require('make-fetch-happen').defaults({
  cachePath: './my-local-cache'
})

fetch('https://registry.npmjs.org/make-fetch-happen') // will always use the cache
</code></pre>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; minipass-fetch options</code></h4>
<p>The following options for <code>minipass-fetch</code> are used as-is:</p>
<ul>
<li>method</li>
<li>body</li>
<li>redirect</li>
<li>follow</li>
<li>timeout</li>
<li>compress</li>
<li>size</li>
</ul>
<p>These other options are modified or augmented by make-fetch-happen:</p>
<ul>
<li>headers - Default <code>User-Agent</code> set to make-fetch happen. <code>Connection</code> is set to <code>keep-alive</code> or <code>close</code> automatically depending on <code>opts.agent</code>.</li>
<li>agent
<ul>
<li>If agent is null, an http or https Agent will be automatically used. By default, these will be <code>http.globalAgent</code> and <code>https.globalAgent</code>.</li>
<li>If <a href="#opts-proxy"><code>opts.proxy</code></a> is provided and <code>opts.agent</code> is null, the agent will be set to an appropriate proxy-handling agent.</li>
<li>If <code>opts.agent</code> is an object, it will be used as the request-pooling agent argument for this request.</li>
<li>If <code>opts.agent</code> is <code>false</code>, it will be passed as-is to the underlying request library. This causes a new Agent to be spawned for every request.</li>
</ul>
</li>
</ul>
<p>For more details, see <a href="https://github.com/npm/minipass-fetch#options">the documentation for <code>minipass-fetch</code> itself</a>.</p>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; make-fetch-happen options</code></h4>
<p>make-fetch-happen augments the <code>minipass-fetch</code> API with additional features available through extra options. The following extra options are available:</p>
<ul>
<li><a href="#opts-cache-path"><code>opts.cachePath</code></a> - Cache target to read/write</li>
<li><a href="#opts-cache"><code>opts.cache</code></a> - <code>fetch</code> cache mode. Controls cache <em>behavior</em>.</li>
<li><a href="#opts-proxy"><code>opts.proxy</code></a> - Proxy agent</li>
<li><a href="#opts-no-proxy"><code>opts.noProxy</code></a> - Domain segments to disable proxying for.</li>
<li><a href="#https-opts"><code>opts.ca, opts.cert, opts.key, opts.strictSSL</code></a></li>
<li><a href="#opts-local-address"><code>opts.localAddress</code></a></li>
<li><a href="#opts-max-sockets"><code>opts.maxSockets</code></a></li>
<li><a href="#opts-retry"><code>opts.retry</code></a> - Request retry settings</li>
<li><a href="#opts-onretry"><code>opts.onRetry</code></a> - a function called whenever a retry is attempted</li>
<li><a href="#opts-integrity"><code>opts.integrity</code></a> - <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">Subresource Integrity</a> metadata.</li>
</ul>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; opts.cachePath</code></h4>
<p>A string <code>Path</code> to be used as the cache root for <a href="https://npm.im/cacache"><code>cacache</code></a>.</p>
<p><strong>NOTE</strong>: Requests will not be cached unless their response bodies are consumed. You will need to use one of the <code>res.json()</code>, <code>res.buffer()</code>, etc methods on the response, or drain the <code>res.body</code> stream, in order for it to be written.</p>
<p>The default cache manager also adds the following headers to cached responses:</p>
<ul>
<li><code>X-Local-Cache</code>: Path to the cache the content was found in</li>
<li><code>X-Local-Cache-Key</code>: Unique cache entry key for this response</li>
<li><code>X-Local-Cache-Mode</code>: Either <code>stream</code> or <code>buffer</code> to indicate how the response was read from cacache</li>
<li><code>X-Local-Cache-Hash</code>: Specific integrity hash for the cached entry</li>
<li><code>X-Local-Cache-Status</code>: One of <code>miss</code>, <code>hit</code>, <code>stale</code>, <code>revalidated</code>, <code>updated</code>, or <code>skip</code> to signal how the response was created</li>
<li><code>X-Local-Cache-Time</code>: UTCString of the cache insertion time for the entry</li>
</ul>
<p>Using <a href="https://npm.im/cacache"><code>cacache</code></a>, a call like this may be used to
manually fetch the cached entry:</p>
<pre><code class="language-javascript">const h = response.headers
cacache.get(h.get('x-local-cache'), h.get('x-local-cache-key'))

// grab content only, directly:
cacache.get.byDigest(h.get('x-local-cache'), h.get('x-local-cache-hash'))
</code></pre>
<h5>Example</h5>
<pre><code class="language-javascript">fetch('https://registry.npmjs.org/make-fetch-happen', {
  cachePath: './my-local-cache'
}) // -&gt; 200-level response will be written to disk
</code></pre>
<p>A possible (minimal) implementation for <code>MyCustomRedisCache</code>:</p>
<pre><code class="language-javascript">const bluebird = require('bluebird')
const redis = require(&quot;redis&quot;)
bluebird.promisifyAll(redis.RedisClient.prototype)
class MyCustomRedisCache {
  constructor (opts) {
    this.redis = redis.createClient(opts)
  }
  match (req) {
    return this.redis.getAsync(req.url).then(res =&gt; {
      if (res) {
        const parsed = JSON.parse(res)
        return new fetch.Response(parsed.body, {
          url: req.url,
          headers: parsed.headers,
          status: 200
        })
      }
    })
  }
  put (req, res) {
    return res.buffer().then(body =&gt; {
      return this.redis.setAsync(req.url, JSON.stringify({
        body: body,
        headers: res.headers.raw()
      }))
    }).then(() =&gt; {
      // return the response itself
      return res
    })
  }
  'delete' (req) {
    return this.redis.unlinkAsync(req.url)
  }
}
</code></pre>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; opts.cache</code></h4>
<p>This option follows the standard <code>fetch</code> API cache option. This option will do nothing if <a href="#opts-cache-path"><code>opts.cachePath</code></a> is null. The following values are accepted (as strings):</p>
<ul>
<li><code>default</code> - Fetch will inspect the HTTP cache on the way to the network. If there is a fresh response it will be used. If there is a stale response a conditional request will be created, and a normal request otherwise. It then updates the HTTP cache with the response. If the revalidation request fails (for example, on a 500 or if you're offline), the stale response will be returned.</li>
<li><code>no-store</code> - Fetch behaves as if there is no HTTP cache at all.</li>
<li><code>reload</code> - Fetch behaves as if there is no HTTP cache on the way to the network. Ergo, it creates a normal request and updates the HTTP cache with the response.</li>
<li><code>no-cache</code> - Fetch creates a conditional request if there is a response in the HTTP cache and a normal request otherwise. It then updates the HTTP cache with the response.</li>
<li><code>force-cache</code> - Fetch uses any response in the HTTP cache matching the request, not paying attention to staleness. If there was no response, it creates a normal request and updates the HTTP cache with the response.</li>
<li><code>only-if-cached</code> - Fetch uses any response in the HTTP cache matching the request, not paying attention to staleness. If there was no response, it returns a network error. (Can only be used when request’s mode is &quot;same-origin&quot;. Any cached redirects will be followed assuming request’s redirect mode is &quot;follow&quot; and the redirects do not violate request’s mode.)</li>
</ul>
<p>(Note: option descriptions are taken from https://fetch.spec.whatwg.org/#http-network-or-cache-fetch)</p>
<h5>Example</h5>
<pre><code class="language-javascript">const fetch = require('make-fetch-happen').defaults({
  cachePath: './my-cache'
})

// Will error with ENOTCACHED if we haven't already cached this url
fetch('https://registry.npmjs.org/make-fetch-happen', {
  cache: 'only-if-cached'
})

// Will refresh any local content and cache the new response
fetch('https://registry.npmjs.org/make-fetch-happen', {
  cache: 'reload'
})

// Will use any local data, even if stale. Otherwise, will hit network.
fetch('https://registry.npmjs.org/make-fetch-happen', {
  cache: 'force-cache'
})
</code></pre>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; opts.proxy</code></h4>
<p>A string or <code>new url.URL()</code>-d URI to proxy through. Different Proxy handlers will be
used depending on the proxy's protocol.</p>
<p>Additionally, <code>process.env.HTTP_PROXY</code>, <code>process.env.HTTPS_PROXY</code>, and
<code>process.env.PROXY</code> are used if present and no <code>opts.proxy</code> value is provided.</p>
<p>(Pending) <code>process.env.NO_PROXY</code> may also be configured to skip proxying requests for all, or specific domains.</p>
<h5>Example</h5>
<pre><code class="language-javascript">fetch('https://registry.npmjs.org/make-fetch-happen', {
  proxy: 'https://corporate.yourcompany.proxy:4445'
})

fetch('https://registry.npmjs.org/make-fetch-happen', {
  proxy: {
    protocol: 'https:',
    hostname: 'corporate.yourcompany.proxy',
    port: 4445
  }
})
</code></pre>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; opts.noProxy</code></h4>
<p>If present, should be a comma-separated string or an array of domain extensions
that a proxy should <em>not</em> be used for.</p>
<p>This option may also be provided through <code>process.env.NO_PROXY</code>.</p>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; opts.ca, opts.cert, opts.key, opts.strictSSL</code></h4>
<p>These values are passed in directly to the HTTPS agent and will be used for both
proxied and unproxied outgoing HTTPS requests. They mostly correspond to the
same options the <code>https</code> module accepts, which will be themselves passed to
<code>tls.connect()</code>. <code>opts.strictSSL</code> corresponds to <code>rejectUnauthorized</code>.</p>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; opts.localAddress</code></h4>
<p>Passed directly to <code>http</code> and <code>https</code> request calls. Determines the local
address to bind to.</p>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; opts.maxSockets</code></h4>
<p>Default: 15</p>
<p>Maximum number of active concurrent sockets to use for the underlying
Http/Https/Proxy agents. This setting applies once per spawned agent.</p>
<p>15 is probably a <em>pretty good value</em> for most use-cases, and balances speed
with, uh, not knocking out people's routers. 🤓</p>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; opts.retry</code></h4>
<p>An object that can be used to tune request retry settings. Retries will only be attempted on the following conditions:</p>
<ul>
<li>Request method is NOT <code>POST</code> AND</li>
<li>Request status is one of: <code>408</code>, <code>420</code>, <code>429</code>, or any status in the 500-range. OR</li>
<li>Request errored with <code>ECONNRESET</code>, <code>ECONNREFUSED</code>, <code>EADDRINUSE</code>, <code>ETIMEDOUT</code>, or the <code>fetch</code> error <code>request-timeout</code>.</li>
</ul>
<p>The following are worth noting as explicitly not retried:</p>
<ul>
<li><code>getaddrinfo ENOTFOUND</code> and will be assumed to be either an unreachable domain or the user will be assumed offline. If a response is cached, it will be returned immediately.</li>
</ul>
<p>If <code>opts.retry</code> is <code>false</code>, it is equivalent to <code>{retries: 0}</code></p>
<p>If <code>opts.retry</code> is a number, it is equivalent to <code>{retries: num}</code></p>
<p>The following retry options are available if you want more control over it:</p>
<ul>
<li>retries</li>
<li>factor</li>
<li>minTimeout</li>
<li>maxTimeout</li>
<li>randomize</li>
</ul>
<p>For details on what each of these do, refer to the <a href="https://npm.im/retry"><code>retry</code></a> documentation.</p>
<h5>Example</h5>
<pre><code class="language-javascript">fetch('https://flaky.site.com', {
  retry: {
    retries: 10,
    randomize: true
  }
})

fetch('http://reliable.site.com', {
  retry: false
})

fetch('http://one-more.site.com', {
  retry: 3
})
</code></pre>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; opts.onRetry</code></h4>
<p>A function called whenever a retry is attempted.</p>
<h5>Example</h5>
<pre><code class="language-javascript">fetch('https://flaky.site.com', {
  onRetry() {
    console.log('we will retry!')
  }
})
</code></pre>
<h4><!-- raw HTML omitted --><!-- raw HTML omitted --> <code>&gt; opts.integrity</code></h4>
<p>Matches the response body against the given <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">Subresource Integrity</a> metadata. If verification fails, the request will fail with an <code>EINTEGRITY</code> error.</p>
<p><code>integrity</code> may either be a string or an <a href="https://npm.im/ssri"><code>ssri</code></a> <code>Integrity</code>-like.</p>
<h5>Example</h5>
<pre><code class="language-javascript">fetch('https://registry.npmjs.org/make-fetch-happen/-/make-fetch-happen-1.0.0.tgz', {
  integrity: 'sha1-o47j7zAYnedYFn1dF/fR9OV3z8Q='
}) // -&gt; ok

fetch('https://malicious-registry.org/make-fetch-happen/-/make-fetch-happen-1.0.0.tgz', {
  integrity: 'sha1-o47j7zAYnedYFn1dF/fR9OV3z8Q='
}) // Error: EINTEGRITY
</code></pre>
<h3><!-- raw HTML omitted --><!-- raw HTML omitted --> Message From Our Sponsors</h3>
<p><img src="stop.gif" alt="" /></p>
<p><img src="happening.gif" alt="" /></p>
</body></html>