<html><head><title>README.md</title></head><body><h1>fastq</h1>
<p><img src="https://github.com/mcollina/fastq/workflows/ci/badge.svg" alt="ci" />
<a href="https://badge.fury.io/js/fastq"><img src="https://badge.fury.io/js/fastq.svg" alt="npm version" /></a></p>
<p>Fast, in memory work queue.</p>
<p>Benchmarks (1 million tasks):</p>
<ul>
<li>setImmediate: 812ms</li>
<li>fastq: 854ms</li>
<li>async.queue: 1298ms</li>
<li>neoAsync.queue: 1249ms</li>
</ul>
<p>Obtained on node 12.16.1, on a dedicated server.</p>
<p>If you need zero-overhead series function call, check out
<a href="http://npm.im/fastseries">fastseries</a>. For zero-overhead parallel
function call, check out <a href="http://npm.im/fastparallel">fastparallel</a>.</p>
<p><a href="https://github.com/feross/standard"><img src="https://raw.githubusercontent.com/feross/standard/master/badge.png" alt="js-standard-style" /></a></p>
<ul>
<li><!-- raw HTML omitted -->Installation<!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted -->Usage<!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted -->API<!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted -->Licence &amp; copyright<!-- raw HTML omitted --></li>
</ul>
<h2>Install</h2>
<p><code>npm i fastq --save</code></p>
<h2>Usage (callback API)</h2>
<pre><code class="language-js">'use strict'

const queue = require('fastq')(worker, 1)

queue.push(42, function (err, result) {
  if (err) { throw err }
  console.log('the result is', result)
})

function worker (arg, cb) {
  cb(null, arg * 2)
}
</code></pre>
<h2>Usage (promise API)</h2>
<pre><code class="language-js">const queue = require('fastq').promise(worker, 1)

async function worker (arg) {
  return arg * 2
}

async function run () {
  const result = await queue.push(42)
  console.log('the result is', result)
}

run()
</code></pre>
<h3>Setting &quot;this&quot;</h3>
<pre><code class="language-js">'use strict'

const that = { hello: 'world' }
const queue = require('fastq')(that, worker, 1)

queue.push(42, function (err, result) {
  if (err) { throw err }
  console.log(this)
  console.log('the result is', result)
})

function worker (arg, cb) {
  console.log(this)
  cb(null, arg * 2)
}
</code></pre>
<h3>Using with TypeScript (callback API)</h3>
<pre><code class="language-ts">'use strict'

import * as fastq from &quot;fastq&quot;;
import type { queue, done } from &quot;fastq&quot;;

type Task = {
  id: number
}

const q: queue&lt;Task&gt; = fastq(worker, 1)

q.push({ id: 42})

function worker (arg: Task, cb: done) {
  console.log(arg.id)
  cb(null)
}
</code></pre>
<h3>Using with TypeScript (promise API)</h3>
<pre><code class="language-ts">'use strict'

import * as fastq from &quot;fastq&quot;;
import type { queueAsPromised } from &quot;fastq&quot;;

type Task = {
  id: number
}

const q: queueAsPromised&lt;Task&gt; = fastq.promise(asyncWorker, 1)

q.push({ id: 42}).catch((err) =&gt; console.error(err))

async function asyncWorker (arg: Task): Promise&lt;void&gt; {
  // No need for a try-catch block, fastq handles errors automatically
  console.log(arg.id)
}
</code></pre>
<h2>API</h2>
<ul>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->fastqueue()<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->push()<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->unshift()<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->pause()<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->resume()<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->idle()<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->length()<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->getQueue()<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->kill()<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->killAndDrain()<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->error()<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->concurrency<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->drain<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->empty<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->queue#<!-- raw HTML omitted -->saturated<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->fastqueue.promise()<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ul>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>fastqueue([that], worker, concurrency)</h3>
<p>Creates a new queue.</p>
<p>Arguments:</p>
<ul>
<li><code>that</code>, optional context of the <code>worker</code> function.</li>
<li><code>worker</code>, worker function, it would be called with <code>that</code> as <code>this</code>,
if that is specified.</li>
<li><code>concurrency</code>, number of concurrent tasks that could be executed in
parallel.</li>
</ul>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.push(task, done)</h3>
<p>Add a task at the end of the queue. <code>done(err, result)</code> will be called
when the task was processed.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.unshift(task, done)</h3>
<p>Add a task at the beginning of the queue. <code>done(err, result)</code> will be called
when the task was processed.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.pause()</h3>
<p>Pause the processing of tasks. Currently worked tasks are not
stopped.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.resume()</h3>
<p>Resume the processing of tasks.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.idle()</h3>
<p>Returns <code>false</code> if there are tasks being processed or waiting to be processed.
<code>true</code> otherwise.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.length()</h3>
<p>Returns the number of tasks waiting to be processed (in the queue).</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.getQueue()</h3>
<p>Returns all the tasks be processed (in the queue). Returns empty array when there are no tasks</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.kill()</h3>
<p>Removes all tasks waiting to be processed, and reset <code>drain</code> to an empty
function.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.killAndDrain()</h3>
<p>Same than <code>kill</code> but the <code>drain</code> function will be called before reset to empty.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.error(handler)</h3>
<p>Set a global error handler. <code>handler(err, task)</code> will be called
each time a task is completed, <code>err</code> will be not null if the task has thrown an error.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.concurrency</h3>
<p>Property that returns the number of concurrent tasks that could be executed in
parallel. It can be altered at runtime.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.drain</h3>
<p>Function that will be called when the last
item from the queue has been processed by a worker.
It can be altered at runtime.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.empty</h3>
<p>Function that will be called when the last
item from the queue has been assigned to a worker.
It can be altered at runtime.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>queue.saturated</h3>
<p>Function that will be called when the queue hits the concurrency
limit.
It can be altered at runtime.</p>
<hr />
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3>fastqueue.promise([that], worker(arg), concurrency)</h3>
<p>Creates a new queue with <code>Promise</code> apis. It also offers all the methods
and properties of the object returned by <a href="#fastqueue"><code>fastqueue</code></a> with the modified
<a href="#pushPromise"><code>push</code></a> and <a href="#unshiftPromise"><code>unshift</code></a> methods.</p>
<p>Node v10+ is required to use the promisified version.</p>
<p>Arguments:</p>
<ul>
<li><code>that</code>, optional context of the <code>worker</code> function.</li>
<li><code>worker</code>, worker function, it would be called with <code>that</code> as <code>this</code>,
if that is specified. It MUST return a <code>Promise</code>.</li>
<li><code>concurrency</code>, number of concurrent tasks that could be executed in
parallel.</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4>queue.push(task) =&gt; Promise</h4>
<p>Add a task at the end of the queue. The returned <code>Promise</code>  will be fulfilled (rejected)
when the task is completed successfully (unsuccessfully).</p>
<p>This promise could be ignored as it will not lead to a <code>'unhandledRejection'</code>.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4>queue.unshift(task) =&gt; Promise</h4>
<p>Add a task at the beginning of the queue. The returned <code>Promise</code>  will be fulfilled (rejected)
when the task is completed successfully (unsuccessfully).</p>
<p>This promise could be ignored as it will not lead to a <code>'unhandledRejection'</code>.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4>queue.drained() =&gt; Promise</h4>
<p>Wait for the queue to be drained. The returned <code>Promise</code> will be resolved when all tasks in the queue have been processed by a worker.</p>
<p>This promise could be ignored as it will not lead to a <code>'unhandledRejection'</code>.</p>
<h2>License</h2>
<p>ISC</p>
</body></html>