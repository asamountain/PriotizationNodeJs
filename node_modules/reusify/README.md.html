<html><head><title>README.md</title></head><body><h1>reusify</h1>
<p><a href="https://badge.fury.io/js/reusify"><img src="https://badge.fury.io/js/reusify.svg" alt="npm version" /></a>
<a href="https://travis-ci.org/mcollina/reusify"><img src="https://api.travis-ci.org/mcollina/reusify.svg" alt="Build Status" /></a>
<a href="https://coveralls.io/github/mcollina/reusify?branch=master"><img src="https://coveralls.io/repos/mcollina/reusify/badge.svg?branch=master&amp;service=github" alt="Coverage Status" /></a></p>
<p>Reuse your objects and functions for maximum speed. This technique will
make any function run ~10% faster. You call your functions a
lot, and it adds up quickly in hot code paths.</p>
<pre><code>$ node benchmarks/createNoCodeFunction.js
Total time 53133
Total iterations 100000000
Iteration/s 1882069.5236482036

$ node benchmarks/reuseNoCodeFunction.js
Total time 50617
Total iterations 100000000
Iteration/s 1975620.838848608
</code></pre>
<p>The above benchmark uses fibonacci to simulate a real high-cpu load.
The actual numbers might differ for your use case, but the difference
should not.</p>
<p>The benchmark was taken using Node v6.10.0.</p>
<p>This library was extracted from
<a href="http://npm.im/fastparallel">fastparallel</a>.</p>
<h2>Example</h2>
<pre><code class="language-js">var reusify = require('reusify')
var fib = require('reusify/benchmarks/fib')
var instance = reusify(MyObject)

// get an object from the cache,
// or creates a new one when cache is empty
var obj = instance.get()

// set the state
obj.num = 100
obj.func()

// reset the state.
// if the state contains any external object
// do not use delete operator (it is slow)
// prefer set them to null
obj.num = 0

// store an object in the cache
instance.release(obj)

function MyObject () {
  // you need to define this property
  // so V8 can compile MyObject into an
  // hidden class
  this.next = null
  this.num = 0

  var that = this

  // this function is never reallocated,
  // so it can be optimized by V8
  this.func = function () {
    if (null) {
      // do nothing
    } else {
      // calculates fibonacci
      fib(that.num)
    }
  }
}
</code></pre>
<p>The above example was intended for synchronous code, let's see async:</p>
<pre><code class="language-js">var reusify = require('reusify')
var instance = reusify(MyObject)

for (var i = 0; i &lt; 100; i++) {
  getData(i, console.log)
}

function getData (value, cb) {
  var obj = instance.get()

  obj.value = value
  obj.cb = cb
  obj.run()
}

function MyObject () {
  this.next = null
  this.value = null

  var that = this

  this.run = function () {
    asyncOperation(that.value, that.handle)
  }

  this.handle = function (err, result) {
    that.cb(err, result)
    that.value = null
    that.cb = null
    instance.release(that)
  }
}
</code></pre>
<p>Also note how in the above examples, the code, that consumes an istance of <code>MyObject</code>,
reset the state to initial condition, just before storing it in the cache.
That's needed so that every subsequent request for an instance from the cache,
could get a clean instance.</p>
<h2>Why</h2>
<p>It is faster because V8 doesn't have to collect all the functions you
create. On a short-lived benchmark, it is as fast as creating the
nested function, but on a longer time frame it creates less
pressure on the garbage collector.</p>
<h2>Other examples</h2>
<p>If you want to see some complex example, checkout <a href="https://github.com/fastify/middie">middie</a> and <a href="https://github.com/mcollina/steed">steed</a>.</p>
<h2>Acknowledgements</h2>
<p>Thanks to <a href="https://github.com/trevnorris">Trevor Norris</a> for
getting me down the rabbit hole of performance, and thanks to <a href="http://github.com/mafintosh">Mathias
Buss</a> for suggesting me to share this
trick.</p>
<h2>License</h2>
<p>MIT</p>
</body></html>