<html><head><title>README.md</title></head><body><h1>minipass-flush</h1>
<p>A Minipass stream that calls a flush function before emitting 'end'</p>
<h2>USAGE</h2>
<pre><code class="language-js">const Flush = require('minipass-flush')
cons f = new Flush({
  flush (cb) {
    // call the cb when done, or return a promise
    // the 'end' event will wait for it, along with
    // close, finish, and prefinish.
    // call the cb with an error, or return a rejecting
    // promise to emit 'error' instead of doing the 'end'
    return rerouteAllEncryptions().then(() =&gt; clearAllChannels())
  },
  // all other minipass options accepted as well
})

someDataSource.pipe(f).on('end', () =&gt; {
  // proper flushing has been accomplished
})

// Or as a subclass implementing a 'flush' method:
class MyFlush extends Flush {
  flush (cb) {
    // old fashioned callback style!
    rerouteAllEncryptions(er =&gt; {
      if (er)
        return cb(er)
      clearAllChannels(er =&gt; {
        if (er)
          cb(er)
        cb()
      })
    })
  }
}
</code></pre>
<p>That's about it.</p>
<p>If your <code>flush</code> method doesn't have to do anything asynchronous, then it's
better to call the callback right away in this tick, rather than returning
<code>Promise.resolve()</code>, so that the <code>end</code> event can happen as soon as
possible.</p>
</body></html>