<html><head><title>README.md</title></head><body><h1>Nano ID</h1>
<p><!-- raw HTML omitted --></p>
<p><strong>English</strong> | <a href="./README.ru.md">Русский</a> | <a href="./README.zh-CN.md">简体中文</a> | <a href="./README.id-ID.md">Bahasa Indonesia</a></p>
<p>A tiny, secure, URL-friendly, unique string ID generator for JavaScript.</p>
<blockquote>
<p>“An amazing level of senseless perfectionism,
which is simply impossible not to respect.”</p>
</blockquote>
<ul>
<li><strong>Small.</strong> 130 bytes (minified and gzipped). No dependencies.
<a href="https://github.com/ai/size-limit">Size Limit</a> controls the size.</li>
<li><strong>Fast.</strong> It is 2 times faster than UUID.</li>
<li><strong>Safe.</strong> It uses hardware random generator. Can be used in clusters.</li>
<li><strong>Short IDs.</strong> It uses a larger alphabet than UUID (<code>A-Za-z0-9_-</code>).
So ID size was reduced from 36 to 21 symbols.</li>
<li><strong>Portable.</strong> Nano ID was ported
to <a href="#other-programming-languages">20 programming languages</a>.</li>
</ul>
<pre><code class="language-js">import { nanoid } from 'nanoid'
model.id = nanoid() //=&gt; &quot;V1StGXR8_Z5jdHi6B-myT&quot;
</code></pre>
<p>Supports modern browsers, IE <a href="https://developer.epages.com/blog/coding/how-to-transpile-node-modules-with-babel-and-webpack-in-a-monorepo/">with Babel</a>, Node.js and React Native.</p>
<!-- raw HTML omitted -->
<h2>Table of Contents</h2>
<ul>
<li><a href="#comparison-with-uuid">Comparison with UUID</a></li>
<li><a href="#benchmark">Benchmark</a></li>
<li><a href="#security">Security</a></li>
<li><a href="#api">API</a>
<ul>
<li><a href="#blocking">Blocking</a></li>
<li><a href="#async">Async</a></li>
<li><a href="#non-secure">Non-Secure</a></li>
<li><a href="#custom-alphabet-or-size">Custom Alphabet or Size</a></li>
<li><a href="#custom-random-bytes-generator">Custom Random Bytes Generator</a></li>
</ul>
</li>
<li><a href="#usage">Usage</a>
<ul>
<li><a href="#ie">IE</a></li>
<li><a href="#react">React</a></li>
<li><a href="#react-native">React Native</a></li>
<li><a href="#rollup">Rollup</a></li>
<li><a href="#pouchdb-and-couchdb">PouchDB and CouchDB</a></li>
<li><a href="#mongoose">Mongoose</a></li>
<li><a href="#web-workers">Web Workers</a></li>
<li><a href="#cli">CLI</a></li>
<li><a href="#other-programming-languages">Other Programming Languages</a></li>
</ul>
</li>
<li><a href="#tools">Tools</a></li>
</ul>
<h2>Comparison with UUID</h2>
<p>Nano ID is quite comparable to UUID v4 (random-based).
It has a similar number of random bits in the ID
(126 in Nano ID and 122 in UUID), so it has a similar collision probability:</p>
<blockquote>
<p>For there to be a one in a billion chance of duplication,
103 trillion version 4 IDs must be generated.</p>
</blockquote>
<p>There are three main differences between Nano ID and UUID v4:</p>
<ol>
<li>Nano ID uses a bigger alphabet, so a similar number of random bits
are packed in just 21 symbols instead of 36.</li>
<li>Nano ID code is <strong>4 times less</strong> than <code>uuid/v4</code> package:
130 bytes instead of 483.</li>
<li>Because of memory allocation tricks, Nano ID is <strong>2 times</strong> faster than UUID.</li>
</ol>
<h2>Benchmark</h2>
<pre><code class="language-rust">$ node ./test/benchmark.js
crypto.randomUUID         25,603,857 ops/sec
@napi-rs/uuid              9,973,819 ops/sec
uid/secure                 8,234,798 ops/sec
@lukeed/uuid               7,464,706 ops/sec
nanoid                     5,616,592 ops/sec
customAlphabet             3,115,207 ops/sec
uuid v4                    1,535,753 ops/sec
secure-random-string         388,226 ops/sec
uid-safe.sync                363,489 ops/sec
cuid                         187,343 ops/sec
shortid                       45,758 ops/sec

Async:
nanoid/async                  96,094 ops/sec
async customAlphabet          97,184 ops/sec
async secure-random-string    92,794 ops/sec
uid-safe                      90,684 ops/sec

Non-secure:
uid                       67,376,692 ops/sec
nanoid/non-secure          2,849,639 ops/sec
rndm                       2,674,806 ops/sec
</code></pre>
<p>Test configuration: ThinkPad X1 Carbon Gen 9, Fedora 34, Node.js 16.10.</p>
<h2>Security</h2>
<p><em>See a good article about random generators theory:
<a href="https://gist.github.com/joepie91/7105003c3b26e65efcea63f3db82dfba">Secure random values (in Node.js)</a></em></p>
<ul>
<li>
<p><strong>Unpredictability.</strong> Instead of using the unsafe <code>Math.random()</code>, Nano ID
uses the <code>crypto</code> module in Node.js and the Web Crypto API in browsers.
These modules use unpredictable hardware random generator.</p>
</li>
<li>
<p><strong>Uniformity.</strong> <code>random % alphabet</code> is a popular mistake to make when coding
an ID generator. The distribution will not be even; there will be a lower
chance for some symbols to appear compared to others. So, it will reduce
the number of tries when brute-forcing. Nano ID uses a <a href="https://github.com/ai/nanoid/blob/main/index.js">better algorithm</a>
and is tested for uniformity.</p>
<p><!-- raw HTML omitted --></p>
</li>
<li>
<p><strong>Well-documented:</strong> all Nano ID hacks are documented. See comments
in <a href="https://github.com/ai/nanoid/blob/main/index.js">the source</a>.</p>
</li>
<li>
<p><strong>Vulnerabilities:</strong> to report a security vulnerability, please use
the <a href="https://tidelift.com/security">Tidelift security contact</a>.
Tidelift will coordinate the fix and disclosure.</p>
</li>
</ul>
<h2>Install</h2>
<pre><code class="language-bash">npm install --save nanoid
</code></pre>
<p>For quick hacks, you can load Nano ID from CDN. Though, it is not recommended
to be used in production because of the lower loading performance.</p>
<pre><code class="language-js">import { nanoid } from 'https://cdn.jsdelivr.net/npm/nanoid/nanoid.js'
</code></pre>
<p>Nano ID provides ES modules. You do not need to do anything to use Nano ID
as ESM in webpack, Rollup, Parcel, or Node.js.</p>
<pre><code class="language-js">import { nanoid } from 'nanoid'
</code></pre>
<p>In Node.js you can use CommonJS import:</p>
<pre><code class="language-js">const { nanoid } = require('nanoid')
</code></pre>
<h2>API</h2>
<p>Nano ID has 3 APIs: normal (blocking), asynchronous, and non-secure.</p>
<p>By default, Nano ID uses URL-friendly symbols (<code>A-Za-z0-9_-</code>) and returns an ID
with 21 characters (to have a collision probability similar to UUID v4).</p>
<h3>Blocking</h3>
<p>The safe and easiest way to use Nano ID.</p>
<p>In rare cases could block CPU from other work while noise collection
for hardware random generator.</p>
<pre><code class="language-js">import { nanoid } from 'nanoid'
model.id = nanoid() //=&gt; &quot;V1StGXR8_Z5jdHi6B-myT&quot;
</code></pre>
<p>If you want to reduce the ID size (and increase collisions probability),
you can pass the size as an argument.</p>
<pre><code class="language-js">nanoid(10) //=&gt; &quot;IRFa-VaY2b&quot;
</code></pre>
<p>Don’t forget to check the safety of your ID size
in our <a href="https://zelark.github.io/nano-id-cc/">ID collision probability</a> calculator.</p>
<p>You can also use a <a href="#custom-alphabet-or-size">custom alphabet</a>
or a <a href="#custom-random-bytes-generator">random generator</a>.</p>
<h3>Async</h3>
<p>To generate hardware random bytes, CPU collects electromagnetic noise.
For most cases, entropy will be already collected.</p>
<p>In the synchronous API during the noise collection, the CPU is busy and
cannot do anything useful (for instance, process another HTTP request).</p>
<p>Using the asynchronous API of Nano ID, another code can run during
the entropy collection.</p>
<pre><code class="language-js">import { nanoid } from 'nanoid/async'

async function createUser () {
  user.id = await nanoid()
}
</code></pre>
<p>Read more about entropy collection in <a href="https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback"><code>crypto.randomBytes</code></a> docs.</p>
<p>Unfortunately, you will lose Web Crypto API advantages in a browser
if you use the asynchronous API. So, currently, in the browser, you are limited
with either security (<code>nanoid</code>), asynchronous behavior (<code>nanoid/async</code>),
or non-secure behavior (<code>nanoid/non-secure</code>) that will be explained
in the next part of the documentation.</p>
<h3>Non-Secure</h3>
<p>By default, Nano ID uses hardware random bytes generation for security
and low collision probability. If you are not so concerned with security,
you can use the faster non-secure generator.</p>
<pre><code class="language-js">import { nanoid } from 'nanoid/non-secure'
const id = nanoid() //=&gt; &quot;Uakgb_J5m9g-0JDMbcJqLJ&quot;
</code></pre>
<h3>Custom Alphabet or Size</h3>
<p><code>customAlphabet</code> allows you to create <code>nanoid</code> with your own alphabet
and ID size.</p>
<pre><code class="language-js">import { customAlphabet } from 'nanoid'
const nanoid = customAlphabet('1234567890abcdef', 10)
model.id = nanoid() //=&gt; &quot;4f90d13a42&quot;
</code></pre>
<pre><code class="language-js">import { customAlphabet } from 'nanoid/async'
const nanoid = customAlphabet('1234567890abcdef', 10)
async function createUser () {
  user.id = await nanoid()
}
</code></pre>
<pre><code class="language-js">import { customAlphabet } from 'nanoid/non-secure'
const nanoid = customAlphabet('1234567890abcdef', 10)
user.id = nanoid()
</code></pre>
<p>Check the safety of your custom alphabet and ID size in our
<a href="https://zelark.github.io/nano-id-cc/">ID collision probability</a> calculator. For more alphabets, check out the options
in <a href="https://github.com/CyberAP/nanoid-dictionary"><code>nanoid-dictionary</code></a>.</p>
<p>Alphabet must contain 256 symbols or less.
Otherwise, the security of the internal generator algorithm is not guaranteed.</p>
<p>In addition to setting a default size, you can change the ID size when calling
the function:</p>
<pre><code class="language-js">import { customAlphabet } from 'nanoid'
const nanoid = customAlphabet('1234567890abcdef', 10)
model.id = nanoid(5) //=&gt; &quot;f01a2&quot;
</code></pre>
<h3>Custom Random Bytes Generator</h3>
<p><code>customRandom</code> allows you to create a <code>nanoid</code> and replace alphabet
and the default random bytes generator.</p>
<p>In this example, a seed-based generator is used:</p>
<pre><code class="language-js">import { customRandom } from 'nanoid'

const rng = seedrandom(seed)
const nanoid = customRandom('abcdef', 10, size =&gt; {
  return (new Uint8Array(size)).map(() =&gt; 256 * rng())
})

nanoid() //=&gt; &quot;fbaefaadeb&quot;
</code></pre>
<p><code>random</code> callback must accept the array size and return an array
with random numbers.</p>
<p>If you want to use the same URL-friendly symbols with <code>customRandom</code>,
you can get the default alphabet using the <code>urlAlphabet</code>.</p>
<pre><code class="language-js">const { customRandom, urlAlphabet } = require('nanoid')
const nanoid = customRandom(urlAlphabet, 10, random)
</code></pre>
<p>Asynchronous and non-secure APIs are not available for <code>customRandom</code>.</p>
<p>Note, that between Nano ID versions we may change random generator
call sequence. If you are using seed-based generators, we do not guarantee
the same result.</p>
<h2>Usage</h2>
<h3>IE</h3>
<p>If you support IE, you need to <a href="https://developer.epages.com/blog/coding/how-to-transpile-node-modules-with-babel-and-webpack-in-a-monorepo/">transpile <code>node_modules</code></a> by Babel
and add <code>crypto</code> alias. Moreover, <code>UInt8Array</code> in IE actually
is not an array and to cope with it, you have to convert it to an array
manually:</p>
<pre><code class="language-js">// polyfills.js
if (!window.crypto &amp;&amp; window.msCrypto) {
  window.crypto = window.msCrypto

  const getRandomValuesDef = window.crypto.getRandomValues

  window.crypto.getRandomValues = function (array) {
    const values = getRandomValuesDef.call(window.crypto, array)
    const result = []

    for (let i = 0; i &lt; array.length; i++) {
      result[i] = values[i];
    }

    return result
  };
}
</code></pre>
<pre><code class="language-js">import './polyfills.js'
import { nanoid } from 'nanoid'
</code></pre>
<h3>React</h3>
<p>There’s no correct way to use Nano ID for React <code>key</code> prop
since it should be consistent among renders.</p>
<pre><code class="language-jsx">function Todos({todos}) {
  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;li key={nanoid()}&gt; /* DON’T DO IT */
          {todo.text}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  )
}
</code></pre>
<p>You should rather try to reach for stable ID inside your list item.</p>
<pre><code class="language-jsx">const todoItems = todos.map((todo) =&gt;
  &lt;li key={todo.id}&gt;
    {todo.text}
  &lt;/li&gt;
)
</code></pre>
<p>In case you don’t have stable IDs you'd rather use index as <code>key</code>
instead of <code>nanoid()</code>:</p>
<pre><code class="language-jsx">const todoItems = todos.map((text, index) =&gt;
  &lt;li key={index}&gt; /* Still not recommended but preferred over nanoid().
                      Only do this if items have no stable IDs. */
    {text}
  &lt;/li&gt;
)
</code></pre>
<h3>React Native</h3>
<p>React Native does not have built-in random generator. The following polyfill
works for plain React Native and Expo starting with <code>39.x</code>.</p>
<ol>
<li>Check <a href="https://github.com/LinusU/react-native-get-random-values"><code>react-native-get-random-values</code></a> docs and install it.</li>
<li>Import it before Nano ID.</li>
</ol>
<pre><code class="language-js">import 'react-native-get-random-values'
import { nanoid } from 'nanoid'
</code></pre>
<h3>Rollup</h3>
<p>For Rollup you will need <a href="https://github.com/rollup/plugins/tree/master/packages/node-resolve"><code>@rollup/plugin-node-resolve</code></a> to bundle browser version
of this library.:</p>
<pre><code class="language-js">  plugins: [
    nodeResolve({
      browser: true
    })
  ]
</code></pre>
<h3>PouchDB and CouchDB</h3>
<p>In PouchDB and CouchDB, IDs can’t start with an underscore <code>_</code>.
A prefix is required to prevent this issue, as Nano ID might use a <code>_</code>
at the start of the ID by default.</p>
<p>Override the default ID with the following option:</p>
<pre><code class="language-js">db.put({
  _id: 'id' + nanoid(),
  …
})
</code></pre>
<h3>Mongoose</h3>
<pre><code class="language-js">const mySchema = new Schema({
  _id: {
    type: String,
    default: () =&gt; nanoid()
  }
})
</code></pre>
<h3>Web Workers</h3>
<p>Web Workers do not have access to a secure random generator.</p>
<p>Security is important in IDs when IDs should be unpredictable.
For instance, in &quot;access by URL&quot; link generation.
If you do not need unpredictable IDs, but you need to use Web Workers,
you can use the non‑secure ID generator.</p>
<pre><code class="language-js">import { nanoid } from 'nanoid/non-secure'
nanoid() //=&gt; &quot;Uakgb_J5m9g-0JDMbcJqLJ&quot;
</code></pre>
<p>Note: non-secure IDs are more prone to collision attacks.</p>
<h3>CLI</h3>
<p>You can get unique ID in terminal by calling <code>npx nanoid</code>. You need only
Node.js in the system. You do not need Nano ID to be installed anywhere.</p>
<pre><code class="language-sh">$ npx nanoid
npx: installed 1 in 0.63s
LZfXLFzPPR4NNrgjlWDxn
</code></pre>
<p>Size of generated ID can be specified with <code>--size</code> (or <code>-s</code>) option:</p>
<pre><code class="language-sh">$ npx nanoid --size 10
L3til0JS4z
</code></pre>
<p>Custom alphabet can be specified with <code>--alphabet</code> (or <code>-a</code>) option
(note that in this case <code>--size</code> is required):</p>
<pre><code class="language-sh">$ npx nanoid --alphabet abc --size 15
bccbcabaabaccab
</code></pre>
<h3>Other Programming Languages</h3>
<p>Nano ID was ported to many languages. You can use these ports to have
the same ID generator on the client and server side.</p>
<ul>
<li><a href="https://github.com/codeyu/nanoid-net">C#</a></li>
<li><a href="https://github.com/mcmikecreations/nanoid_cpp">C++</a></li>
<li><a href="https://github.com/zelark/nano-id">Clojure and ClojureScript</a></li>
<li><a href="https://github.com/JamoCA/cfml-nanoid">ColdFusion/CFML</a></li>
<li><a href="https://github.com/mamantoha/nanoid.cr">Crystal</a></li>
<li><a href="https://github.com/pd4d10/nanoid-dart">Dart &amp; Flutter</a></li>
<li><a href="https://github.com/ianfabs/nanoid">Deno</a></li>
<li><a href="https://github.com/matoous/go-nanoid">Go</a></li>
<li><a href="https://github.com/railsmechanic/nanoid">Elixir</a></li>
<li><a href="https://github.com/MichelBoucey/NanoID">Haskell</a></li>
<li><a href="https://sr.ht/~statianzo/janet-nanoid/">Janet</a></li>
<li><a href="https://github.com/aventrix/jnanoid">Java</a></li>
<li><a href="https://github.com/icyphox/nanoid.nim">Nim</a></li>
<li><a href="https://github.com/routineco/ocaml-nanoid">OCaml</a></li>
<li><a href="https://github.com/tkzwtks/Nanoid-perl">Perl</a></li>
<li><a href="https://github.com/hidehalo/nanoid-php">PHP</a></li>
<li><a href="https://github.com/puyuan/py-nanoid">Python</a>
with <a href="https://pypi.org/project/nanoid-dictionary">dictionaries</a></li>
<li><a href="https://github.com/spa5k/uids-postgres">Postgres Extension</a></li>
<li><a href="https://github.com/hrbrmstr/nanoid">R</a> (with dictionaries)</li>
<li><a href="https://github.com/radeno/nanoid.rb">Ruby</a></li>
<li><a href="https://github.com/nikolay-govorov/nanoid">Rust</a></li>
<li><a href="https://github.com/antiflasher/NanoID">Swift</a></li>
<li><a href="https://share.unison-lang.org/latest/namespaces/hojberg/nanoid">Unison</a></li>
<li><a href="https://github.com/invipal/nanoid">V</a></li>
<li><a href="https://github.com/SasLuca/zig-nanoid">Zig</a></li>
</ul>
<p>For other environments, <a href="#cli">CLI</a> is available to generate IDs from a command line.</p>
<h2>Tools</h2>
<ul>
<li><a href="https://zelark.github.io/nano-id-cc/">ID size calculator</a> shows collision probability when adjusting
the ID alphabet or size.</li>
<li><a href="https://github.com/CyberAP/nanoid-dictionary"><code>nanoid-dictionary</code></a> with popular alphabets to use with <a href="#custom-alphabet-or-size"><code>customAlphabet</code></a>.</li>
<li><a href="https://github.com/y-gagar1n/nanoid-good"><code>nanoid-good</code></a> to be sure that your ID doesn’t contain any obscene words.</li>
</ul>
</body></html>